use crate::glob::Glob;
use anyhow::Context;
use clap::ValueEnum;
use fs_err::tokio as fs;
use relative_path::RelativePathBuf;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, path::PathBuf};

#[derive(Debug, Deserialize, Serialize, Clone, JsonSchema)]
pub struct Config {
    pub creator: Creator,

    #[serde(default)]
    pub codegen: Codegen,

    /// A map of input names to input configurations
    pub inputs: HashMap<String, Input>,
}

pub const FILE_NAME: &str = "truffle.toml";

impl Config {
    pub async fn read() -> anyhow::Result<Config> {
        let config_str = fs::read_to_string(FILE_NAME)
            .await
            .context("Failed to read config file")?;

        // Parse as TOML value to strip the [truffle] table before deserializing
        let mut toml_value: toml::Value =
            toml::from_str(&config_str).context("Failed to parse config file")?;

        // Remove the [truffle] table if it exists (for truffle.toml compatibility)
        if let toml::Value::Table(ref mut table) = toml_value {
            table.remove("truffle");
        }

        // Convert back to string and deserialize as Config
        let cleaned_str =
            toml::to_string(&toml_value).context("Failed to serialize cleaned config")?;
        let config: Config =
            toml::from_str(&cleaned_str).context("Failed to deserialize config")?;

        Ok(config)
    }
}

/// Optional configuration for generated files and code
#[derive(Debug, Deserialize, Serialize, Clone, Default, JsonSchema)]
#[serde(default)]
pub struct Codegen {
    pub style: CodegenStyle,
    /// Generate a TypeScript definition file
    pub typescript: bool,
    /// Strip the file extensions from asset keys
    pub strip_extensions: bool,
    /// Generate the Content data type instead of strings
    pub content: bool,
}

/// The type of Creator
#[derive(Debug, Deserialize, Serialize, Clone, ValueEnum, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum CreatorType {
    /// A personal Roblox account
    User,
    /// A Community on Roblox
    Group,
}

/// The Roblox creator to upload the assets under
#[derive(Debug, Deserialize, Serialize, Clone, JsonSchema)]
pub struct Creator {
    /// The type of Creator
    #[serde(rename = "type")]
    pub ty: CreatorType,
    /// The Creator ID
    pub id: u64,
}

fn default_true() -> bool {
    true
}

/// A collection of assets
#[derive(Debug, Deserialize, Serialize, Clone, JsonSchema)]
pub struct Input {
    /// A glob pattern to match files to upload
    #[schemars(with = "String")]
    pub path: Glob,
    /// The directory path to output the generated code
    pub output_path: PathBuf,

    /// Enable alpha bleeding images. Keep in mind that changing this setting won't invalidate your lockfile or reupload your images
    #[serde(default = "default_true")]
    pub bleed: bool,

    /// A map of paths relative to the input path to existing assets on Roblox
    #[serde(default)]
    #[schemars(with = "HashMap<PathBuf, WebAsset>")]
    pub web: HashMap<RelativePathBuf, WebAsset>,

    /// Emit a warning each time a duplicate file is found
    #[serde(default = "default_true")]
    pub warn_each_duplicate: bool,
}

/// An asset that exists on Roblox
#[derive(Debug, Deserialize, Serialize, Clone, JsonSchema)]
pub struct WebAsset {
    /// The asset ID
    pub id: u64,
}

/// The style of code to generate
#[derive(Debug, Deserialize, Serialize, Default, Clone, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum CodegenStyle {
    #[default]
    /// A flat table is generated with keys that look like asset paths
    Flat,
    /// A nested table is generated by separating the asset paths
    Nested,
}
