use super::model::AssetValue;
use std::collections::BTreeMap;

pub fn render_luau_module(assets: &BTreeMap<String, AssetValue>) -> String {
    format!(
        "-- This file is automatically @generated by truffle.\n\
         -- DO NOT EDIT MANUALLY.\n\n\
         local assets = {}\n\
         return {{\n\
         \tassets = assets\n\
         }}\n",
        serialize_luau(&AssetValue::Table(assets.clone()), 0)
    )
}

pub fn render_dts_module(assets: &BTreeMap<String, AssetValue>) -> String {
    format!(
        "// This file is automatically @generated by truffle.\n\
         // DO NOT EDIT MANUALLY.\n\n\
         export interface AssetMeta {{\n\
         \tid: string;\n\
         \twidth: number;\n\
         \theight: number;\n\
         \trectX?: number;\n\
         \trectY?: number;\n\
         \trectW?: number;\n\
         \trectH?: number;\n\
         \thighlightId?: string;\n\
         \thighlightRectX?: number;\n\
         \thighlightRectY?: number;\n\
         \thighlightRectW?: number;\n\
         \thighlightRectH?: number;\n\
         }}\n\n\
         declare const assets: {}\n\n\
         export {{ assets }};\n",
        serialize_dts(&AssetValue::Table(assets.clone()), 0)
    )
}

fn serialize_luau(value: &AssetValue, indent: usize) -> String {
    let indent_str = "\t".repeat(indent);
    let inner_indent = format!("{}\t", indent_str);
    let first_level = indent == 0;

    match value {
        AssetValue::String(s) => format!("\"{}\"", s.replace('"', "\\\"")),
        AssetValue::Number(n) => n.to_string(),
        AssetValue::Object(meta) => {
            let mut parts = vec!["{".to_string()];
            parts.push(format!("{}id = \"{}\",", inner_indent, meta.id));
            if let Some(w) = meta.width {
                parts.push(format!("{}width = {},", inner_indent, w));
            }
            if let Some(h) = meta.height {
                parts.push(format!("{}height = {},", inner_indent, h));
            }
            if let Some(x) = meta.rect_x {
                parts.push(format!("{}rectX = {},", inner_indent, x));
            }
            if let Some(y) = meta.rect_y {
                parts.push(format!("{}rectY = {},", inner_indent, y));
            }
            if let Some(w) = meta.rect_w {
                parts.push(format!("{}rectW = {},", inner_indent, w));
            }
            if let Some(h) = meta.rect_h {
                parts.push(format!("{}rectH = {},", inner_indent, h));
            }
            if let Some(ref h_id) = meta.highlight_id {
                parts.push(format!("{}highlightId = \"{}\",", inner_indent, h_id));
            }
            if let Some(x) = meta.highlight_rect_x {
                parts.push(format!("{}highlightRectX = {},", inner_indent, x));
            }
            if let Some(y) = meta.highlight_rect_y {
                parts.push(format!("{}highlightRectY = {},", inner_indent, y));
            }
            if let Some(w) = meta.highlight_rect_w {
                parts.push(format!("{}highlightRectW = {},", inner_indent, w));
            }
            if let Some(h) = meta.highlight_rect_h {
                parts.push(format!("{}highlightRectH = {},", inner_indent, h));
            }
            parts.push(format!("{}}}", indent_str));
            let result = parts.join("\n");
            if first_level {
                format!("{}\n", result)
            } else {
                result
            }
        }
        AssetValue::Table(map) => {
            let mut parts = vec!["{".to_string()];
            let mut keys: Vec<String> = map.keys().cloned().collect();
            keys.sort();

            for key in keys {
                let key_str = if is_simple_identifier(&key) {
                    format!("{}{} = ", inner_indent, key)
                } else {
                    format!(
                        "{}[{}] = ",
                        inner_indent,
                        serde_json::to_string(&key).unwrap()
                    )
                };
                let value_str = serialize_luau(&map[&key], indent + 1);
                parts.push(format!("{}{},", key_str, value_str));
            }
            parts.push(format!("{}}}", indent_str));
            let result = parts.join("\n");
            if first_level {
                format!("{}\n", result)
            } else {
                result
            }
        }
    }
}

fn serialize_dts(value: &AssetValue, indent: usize) -> String {
    let indent_str = " ".repeat(indent);
    let inner_indent = format!("{}    ", indent_str);

    match value {
        AssetValue::String(_) | AssetValue::Number(_) | AssetValue::Object(_) => {
            "AssetMeta;".to_string()
        }
        AssetValue::Table(map) => {
            let mut parts = vec!["{".to_string()];
            let mut keys: Vec<String> = map.keys().cloned().collect();
            keys.sort();

            for key in keys {
                let value = &map[&key];
                let key_str = if is_simple_identifier(&key) {
                    format!("{}{}: ", inner_indent, key)
                } else {
                    format!("{}{}: ", inner_indent, serde_json::to_string(&key).unwrap())
                };

                let value_str = match value {
                    AssetValue::Object(_) | AssetValue::String(_) | AssetValue::Number(_) => {
                        "AssetMeta;".to_string()
                    }
                    AssetValue::Table(_) => serialize_dts(value, indent + 4),
                };
                parts.push(format!("{}{}", key_str, value_str));
            }
            parts.push(format!("{}}}", indent_str));
            parts.join("\n")
        }
    }
}

fn is_simple_identifier(key: &str) -> bool {
    let mut chars = key.chars();
    match chars.next() {
        Some(first) if first.is_alphabetic() || first == '_' => (),
        _ => return false,
    }
    chars.all(|c| c.is_alphanumeric() || c == '_')
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::assets::model::{AssetMeta, AssetValue};
    use std::collections::BTreeMap;

    fn sample_assets() -> BTreeMap<String, AssetValue> {
        fn meta(id: &str) -> AssetValue {
            AssetValue::Object(AssetMeta {
                id: id.to_string(),
                width: Some(1536),
                height: Some(864),
                rect_x: None,
                rect_y: None,
                rect_w: None,
                rect_h: None,
                highlight_id: None,
                highlight_rect_x: None,
                highlight_rect_y: None,
                highlight_rect_w: None,
                highlight_rect_h: None,
            })
        }

        let mut rain = BTreeMap::new();
        for idx in 1..=3 {
            rain.insert(
                format!("rain0{idx}.png"),
                meta(&format!("rbxassetid://{idx}")),
            );
        }

        let mut ambience = BTreeMap::new();
        ambience.insert("rain".into(), AssetValue::Table(rain));

        let mut root = BTreeMap::new();
        root.insert("ambience".into(), AssetValue::Table(ambience));
        root
    }

    #[test]
    fn luau_output_contains_expected_blocks() {
        let output = render_luau_module(&sample_assets());
        assert!(output.contains("local assets = {"));
        assert!(output.contains("return {"));
        assert!(output.contains("rain01.png"));
    }

    #[test]
    fn dts_output_contains_expected_tree() {
        let output = render_dts_module(&sample_assets());
        assert!(output.contains("export interface AssetMeta"));
        assert!(output.contains("\"rain02.png\": AssetMeta;"));
    }
}
